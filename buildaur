#!/usr/bin/env python3
# maintainer lxgr <lxgr@protonmail.com>
# this software is licensed under the GPL v3

import os, urllib.request, time, sys, math, json, platform
sys.path.append("/usr/share/buildaur/")
import progressbar_buildaur as progressbar
from buildaur_translations import *
from pyalpm import Handle
from pathlib import Path
from datetime import datetime
# res=os.popen("cat /usr/share/buildaur/res").read()

# global home and pathchecking
home=str(Path.home())
Path(home+"/.cache/buildaur/build").mkdir(parents=True, exist_ok=True)
# colors
yellow="\033[33;1m"
red="\033[31;1m"
thic="\033[1m"
# config file
trans=trans[os.environ["LANG"][:2] if os.environ["LANG"][:2] in ["en", "de"] else "en"]
replace_deps={"vte" : "vte-legacy"}
proto="https"
editor="nano"
compmeth=".tar.zst"
mode="normal"
showPKGBUILD=True
showDiff=False
ask_warn_inst=False
pcarg=mkopts=""
handle=Handle(".", "/var/lib/pacman")
localdb=handle.get_localdb()
args=sys.argv
black=open("/usr/share/buildaur/blacklist").read().split("\n")
pkg_obs=[]
# configfile
conf=open("/etc/buildaur/buildaur.conf").read()
try:
    exec(conf)
except:
    print(trans["conf_warning"]%(yellow))

def get_local_pkgs():
    return [pkg.name for pkg in localdb.search(".*") if pkg.packager == "Unknown Packager"]

def options(string, optlen):
    global mkopts, pcarg, deps_from_local_file
    options.confirm=options.install=options.color=True
    deps_from_local_file=options.chroot=False
    opts={'n' : 'global pcarg; options.confirm=False; pcarg+=" --noconfirm"', 'di' : 'options.install=False', 'co' : 'global yellow, red, thic, mkopts; mkopts+=" -m"; yellow=red=thic=""', 'spgp' : 'global mkopts; mkopts+=" --skippgpcheck"', 'ch' : 'options.chroot=True', 'dlf' : 'global deps_from_local_file; deps_from_local_file=True'}
    for op in opts:
        if string.find(op) != -1:
             exec(opts[op])
             optlen+=len(op)
    if optlen != len(string):
        print(trans["error_opts"]%(red, string))
        exit(1)

def liner(length, names, sep=""):
    width, height = os.get_terminal_size()
    lens=0
    for name in names:
        if lens+len(name)+2 < width-length:
            print(name+"  ", end="")
            lens+=len(name)+2
        else:
            lens=len(name)+2
            print("\n"+(length-len(sep))*" "+sep+name+"  ", end="")
    print("")

def sorter(ver1, ver2):
	arr1=ver1.split("-")[0].split(".")
	arr2=ver2.split("-")[0].split(".")
	for i in range(sorted([len(arr2), len(arr1)])[1]):
		try:
			a=arr1[i]
		except:
			a="0"
		try:
			b=arr2[i]
		except:
			b="0"
		arg1=len(b)*"0"+a
		arg2=len(a)*"0"+b
		arrs=[arg1, arg2]
		if sorted(arrs)[0] == arg2 and arg1 != arg2:
			return ver1
		elif sorted(arrs)[0] == arg1 and arg1 != arg2:
			return ver2
	if ver1.split("-")[1] > ver2.split("-")[1]:
		return ver1
	elif ver2.split("-")[1] > ver1.split("-")[1]:
		return ver2

def resolve(pkgs, type="multiinfo", quiet=False, searchby="name"):
    res=[]
    m=1
    # cut pkglists in 200 pkgs bytes
    pkgss=[pkgs[(i*200)-200:i*200] for i in range(math.ceil(len(pkgs)/200+1))][1:]
    if quiet == False:
        print(trans["downloading"])
    for pkgs in pkgss:
        url=proto+"://aur.archlinux.org/rpc/?v=5&type="+type
        if quiet == False and len(pkgss) > 1:
            progressbar.progress(m, len(pkgss), trans["downloading2"])
            m+=1
        if len(pkgs) == 0:
            exit()
        if type == "search":
            url+="&by="+searchby+"&arg="+pkgs[0]
        else:
            # name processing to avoid bad packagenames
            pkgs=[pkg.replace("+", "%2B") for pkg in pkgs]
            # producing url
            for pkg in pkgs:
                url+="&arg[]="+pkg
        try:
            r=urllib.request.urlopen(url)
        except:
            print(trans["error_server"]%(red))
            exit(1)
        res.append(str(r.read()))
    return res

def info(ress, quiet=False):
    rescount=0
    cutted=[]
    for res in ress:
        exec("info.utf_res="+res)
        jsons=json.loads(info.utf_res.decode())
        rescount+=int(jsons["resultcount"])
        cutted+=jsons["results"]
    return rescount, cutted

def aspinfo(pkgs, quiet):
    cutted=[]
    rescount=0
    print(trans["update_asp"])
    os.system("asp update 2>/dev/null")
    if quiet == False:
        print(trans["collecting"])
    for i, pkg in enumerate(pkgs):
        this=LocalInfo(True, pkg)
        pkgver=this.pkgdata["ver"]
        if pkgver != "-":
            cutted.append({"Name": pkg, "Version": pkgver, "Description": "some pkg from asp", "OutOfDate": "None", "PackageBase": pkg})
            rescount+=1
        if quiet == False:
            progressbar.progress(i+1, int(len(pkgs)), "Collecting "+pkg+"...")
    return rescount, cutted

def update():
    msg=[]
    willinst=[]
    pkgs=get_local_pkgs()
    res=resolve(pkgs)
    rescount, cutted=info(res, False)
    rescount, cutted=aspinfo([pkg for pkg in pkgs if pkg not in [Informer(cutted, i).name for i in range(int(rescount))]], False) if mode == "asp" else (rescount, cutted)
    print(trans["checking"])
    pkgs=[Informer(cutted, i) for i in range(int(rescount))]
    for i, pkg in enumerate(pkgs):
        progressbar.progress(i+1, int(rescount), trans["checking1"]%(pkg.name))
        if pkg.ver == pkg.localver or pkg.name in black:
            pass
        elif sorter(pkg.ver, pkg.localver) == pkg.ver:
            willinst.append(pkg.name)
        elif sorter(pkg.ver, pkg.localver) == pkg.localver:
            msg.append(trans["warning_higher"]%(yellow, pkg.name, pkg.localver, pkg.ver))
            if ask_warn_inst:
                willinst.append(pkg.name)
        if str(pkg.outdate) != "None":
            msg.append(trans["warning_out-of-date"]%(yellow, pkg.name, datetime.utcfromtimestamp(int(pkg.outdate)).strftime('%Y-%m-%d %H:%M:%S')))
    print(trans["done"])
    for i in msg:
        print(i)
    if willinst == []:
        print(trans["nothing"])
    else:
        install(willinst)

class Informer():
    def __init__(self, cutted, pkg):
        global pkg_obs
        splitted=cutted[pkg]
        self.num=pkg
        for name, sname in zip(["name", "ver", "votes", "outdate", "desc", "depends", "makedepends", "optdepends", "license", "url", "maintainer", "submitted", "modified", "popularity", "keywords" ,"pkgbase"], ["Name", "Version", "NumVotes", "OutOfDate", "Description", "Depends", "MakeDepends", "OptDepends", "License", "URL", "Maintainer", "FirstSubmitted", "LastModified", "Popularity", "Keywords", "PackageBase"]):
            try:
                exec("self."+name+"=splitted[sname]")
            except:
                exec("self."+name+"=['None']")
        try:
            pkg=localdb.get_pkg(splitted["Name"])
            self.localver=pkg.version
        except:
            self.localver="---"
        if self.keywords == []:
            self.keywords=["None"]
        pkg_obs.append(self)


class LocalInfo():
    def __init__(self, asp=False, pkg=""):
        path="/usr/share/buildaur/outputter.sh"
        exec("self.pkgdata="+os.popen(path+" asp "+pkg if asp else path).read().split("\n")[0])


def infoout(res, quiet=False, veryquiet=False):
    rescount, cutted=info(res, True)
    for i in range(int(rescount)):
        pkg=Informer(cutted, i)
        if veryquiet:
            print(pkg.name)
        elif quiet:
            print(pkg.name, pkg.ver)
        else:
            print(" "+pkg.name+"-"+pkg.ver+" (local: "+pkg.localver+")")
            print("    "+str(pkg.desc))

def detailinfo(res):
    rescount, cutted=info(res, True)
    for i in range(int(rescount)):
        pkg=Informer(cutted, i)
        for name, value in zip(trans["info_single"], [pkg.name, pkg.pkgbase, pkg.ver, pkg.localver, pkg.desc, pkg.maintainer, pkg.url, datetime.utcfromtimestamp(int(pkg.submitted)).strftime('%Y-%m-%d %H:%M:%S'), datetime.utcfromtimestamp(int(pkg.modified)).strftime('%Y-%m-%d %H:%M:%S'), pkg.popularity, pkg.votes, pkg.outdate if str(pkg.outdate) == 'None' else datetime.utcfromtimestamp(int(pkg.outdate)).strftime('%Y-%m-%d %H:%M:%S')]):
            print(trans["info_single"][name]+(trans["max_name_len"]-len(trans["info_single"][name]))*" "+": "+str(value))
        for name, value in zip(trans["info_arrays"], [pkg.license, pkg.keywords, pkg.depends, pkg.makedepends, pkg.optdepends]):
            print(trans["info_arrays"][name]+(trans["max_name_len"]-len(trans["info_arrays"][name]))*" "+": ", end='')
            liner(trans["max_name_len"]+2, value)
        print("")

def install(pkgs):
    pkgpathes=[]
    start_pkgs=pkgs.copy()
    pkgs=[pkg for pkg in pkg_obs if pkg.name in start_pkgs]
    if len(pkgs) != len(start_pkgs):
        rescount, cutted=aspinfo(start_pkgs, True) if mode == "asp" else info(resolve(start_pkgs), True)
        pkgs=[Informer(cutted, i) for i in range(int(rescount))]

    if len(pkgs) != len(start_pkgs):
        for pkg in start_pkgs:
            if pkg not in [pkg.name for pkg in pkgs]:
                print(trans["error_not_found"]%(red, pkg))
                exit(1)

    print(trans["checking2"])
    if len(pkgs) == 0:
        print(trans["nothing"])
        exit(0)
    # Checking packages for atributes
    for pkg in pkgs:
        if pkg.ver == pkg.localver:
            print(trans["reinstalling"]%(thic, pkg.name, pkg.localver))
        elif pkg.localver == "---":
            pass
        elif sorter(pkg.ver, pkg.localver) == pkg.ver:
            print(trans["updating"]%(thic, pkg.name, pkg.localver, pkg.ver))
        elif sorter(pkg.ver, pkg.localver) == pkg.localver:
            print(trans["warning_higher"]%(yellow, pkg.name, pkg.localver, pkg.ver))
        if str(pkg.outdate) != "None":
            print(trans["warning_out-of-date"]%(yellow, pkg.name, datetime.utcfromtimestamp(int(pkg.outdate)).strftime('%Y-%m-%d %H:%M:%S')))
    # asking to continue
    print("\n"+trans["packages"]%str(len(pkgs)), end='')
    liner(len(trans["packages"]%str(len(pkgs))), [pkg.name+"-"+pkg.ver for pkg in pkgs])
    ask=input(trans["continue"]) if options.confirm else "y"
    if ask == "Y" or ask == "y" or ask == "":
        print("")
        max=str(len(pkgs))
        for i, pkg in enumerate(pkgs):
            # full makeprocess
            # vars
            print(trans["making"]%(str(i+1), max, thic, pkg.name))
            # Git repository
            os.chdir(home+"/.cache/buildaur/build")
            if mode == "asp":
                print(trans["exporting"])
                os.system('rm -rf ./'+pkg.name+' 2>/dev/null; asp export '+pkg.name+' 2>/dev/null')
            else:
                print(trans["cloning"])
                os.system("rm -rf ./"+pkg.pkgbase+" 2>/dev/null;")
                while not os.path.exists("./"+pkg.pkgbase+"/PKGBUILD"):
                    os.system("git clone "+proto+"://aur.archlinux.org/"+pkg.pkgbase+".git")
            os.chdir(os.getcwd()+"/"+pkg.pkgbase)
            # edit
            if showPKGBUILD:
                print(trans["print_pkgb"])
                pkgbuild=open("PKGBUILD", "rt").read()
                print("\033[37m"+str(pkgbuild)+"\033[0m", end="")
            if showDiff:
                print(trans["print_pkgdiff"])
                diff=os.popen('git diff $(git log --pretty=format:"%h" | head -2 | xargs)').read()
                print("\033[37m"+diff+"\033[0m", end="")
            ask=input(trans["edit"]) if options.confirm else "n"
            if ask in ['y', 'Y']:
                os.system(editor+" ./PKGBUILD")
                print(trans["goingon"])
            if ask in ['c', 'C']:
                print(trans["exiting"])
                exit()
            hooks("prehooks")
            deps(pkg)
            # makepkg
            if options.chroot:
                print(trans["update_chroot"])
                os.system("arch-nspawn $CHROOT/root pacman -Syu "+pcarg)
                print(trans["making1"])
                if os.system("PKGEXT='.pkg"+compmeth+"' makechrootpkg -c -r $CHROOT -- -s"+mkopts) != 0:
                    print(trans["error_makepkg"]%(red, pkg.name))
                    exit(1)
            else:
                print(trans["making1"])
                if os.system(" PKGEXT='.pkg"+compmeth+"' makepkg -s "+mkopts) != 0:
                    print(trans["error_makepkg"]%(red, pkg.name))
                    exit(1)
            # Hooks
            hooks("posthooks")
            # Defining pkgpath
            this=LocalInfo()
            arch='any' if "any" in this.pkgdata["arch"] else platform.machine()
            # versioning for packages with multiple packagenames
            for pkgname in this.pkgdata["pkgnames"]:
                pkgpathes.append(os.getcwd()+"/"+pkgname+"-"+this.pkgdata["ver"]+"-"+arch+".pkg"+compmeth)
            os.chdir(home)
            print("")
        # installing packages
        if options.install:
            print(trans["installing"])
            inststring=""
            for path in pkgpathes:
                inststring+=path+" "
            os.system("sudo pacman -U "+pcarg+" "+inststring)
        else:
            print(trans["created"])
            for path in pkgpathes:
                print(" "+path)
    else:
        exit()

def deps(pkg):
    global replace_deps, deps_from_local_file
    if mode == "asp":
        return
    print(trans["checking_deps"])
    this=LocalInfo() if deps_from_local_file else ""
    depends=this.pkgdata["deps"]+this.pkgdata["makedeps"] if deps_from_local_file else pkg.depends+pkg.makedepends
    depends=[pkg for pkg in [dep.split(">")[0].split("<")[0].split("=")[0] for dep in [dep if dep not in replace_deps else replace_deps[dep] for dep in depends]] if str(localdb.get_pkg(pkg)) == "None"]
    if len(depends) > 0:
        rescount, cutted=info(resolve(depends, quiet=True), True)
        if int(rescount) != 0:
            deps=[Informer(cutted, i).name for i in range(int(rescount))]
            curdir=os.getcwd()
            os.chdir(home)
            install(deps)
            print("")
            os.chdir(curdir)

def list_hooks():
    hooktypes=["prehooks", "posthooks", "prerunhooks", "postrunhooks", "hooks"]
    for hookdir in hooktypes:
        print(trans["hooks_off"] if hookdir == "hooks" else ":: "+hookdir+":")
        for hook in sorted(os.listdir("/etc/buildaur/"+hookdir)):
            print(" "+hook)
            print(os.popen('. /etc/buildaur/'+hookdir+'/'+hook+'; echo "  $desc"').read().split("\n")[0])

def hook_activate(hooks):
    for hook in hooks:
        if hook in os.listdir('/etc/buildaur/hooks/'):
            hooktype=os.popen('. /etc/buildaur/hooks/'+hook+' 2>/dev/null; echo $type').read().split("\n")[0]
            os.system('sudo mv /etc/buildaur/hooks/'+hook+' /etc/buildaur/'+hooktype+'hooks/ 2>/dev/null')
            print(trans["hooks_on"]%hook)
        else:
            print(trans["error_not_found"]%(red, hook))

def hook_deactivate(hooks):
    hooktypes=["prehooks", "posthooks", "prerunhooks", "postrunhooks"]
    for hook in hooks:
        a=0
        for hookdir in hooktypes:
            if hook in os.listdir("/etc/buildaur/"+hookdir):
                os.system('sudo mv  /etc/buildaur/'+hookdir+'/'+hook+' /etc/buildaur/hooks/ 2>/dev/null')
                print(trans["hooks_off1"]%hook)
                a=1
        if a != 1:
            print(trans["error_hook_not_found"]%(red, hook))

def help():
    print(trans["help_start"]%(args[0]), end="")
    for type in trans["help"]:
        print("\n   "+trans["help"][type]["desc"])
        for arg in trans["help"][type]["content"]:
            print("      "+arg+(18-len(arg))*" "+": "+trans["help"][type]["content"][arg])

def hooks(type):
    hooks=os.popen("ls /etc/buildaur/"+type).read().split('\n')[:-1]
    if len(hooks) > 0:
        print(trans["running_hook"]%type)
        for hook in hooks:
            print(" "+hook+"...")
            os.system("/etc/buildaur/"+type+"/"+hook+" -u")

if __name__ == "__main__":
    # checking for root
    if home == "/root":
        print(trans["error_root"]%red)
        exit(1)
    # checking if args are given
    if len(args) == 1:
        print(trans["error_no_opts"]%red)
        exit(1)
    # args
    if args[1][:4] == "-Syu":
        options(args[1], 4)
        update()
    elif args[1][:6] == "-aspyu":
        options(args[1], 6)
        mode="asp"
        update()
    elif args[1][:2] == "-S":
        options(args[1], 2)
        pkgs=args[2:]
        if len(pkgs) == 0:
            print(trans["error_no_pkgs"]%red)
            exit(1)
        install(pkgs)
    elif args[1][:4] == "-asp":
        options(args[1], 4)
        pkgs=args[2:]
        if len(pkgs) == 0:
            print(trans["error_no_pkgs"]%red)
            exit(1)
        mode="asp"
        install(pkgs)
    elif args[1] in ["-Q", "-Qq", "-Qqq"]:
        pkgs=get_local_pkgs() if len(args[2:]) == 0 else args[2:]
        res=resolve(pkgs, quiet=True if "qq" in args[1] else False)
        for arg, option in zip(["-Q", "-Qq", "-Qqq"], ["infoout(res)", "infoout(res, quiet=True)", "infoout(res, veryquiet=True)"]):
            if args[1] == arg:
                exec(option)
    elif args[1] in ["-Qs", "-Qsq", "-Qsqq"]:
        searchby="name"
        pkgs=args[2:]
        try:
            secarg=args[2]
        except:
            exit()
        if secarg == "--by":
            if args[3] in ["name", "name-desc", "maintainer", "depends", "makedepends", "optdepends", "checkdepends"]:
                searchby=args[3]
            else:
                print(trans["error_search"]%(red, args[3]))
            del pkgs[0:2]
        for pkg in pkgs:
            res=resolve([pkg], type="search", searchby=searchby, quiet=True if "qq" in args[1] else False)
            for arg, option in zip(["-Qs", "-Qsq", "-Qsqq"], ["infoout(res)", "infoout(res, quiet=True)", "infoout(res, veryquiet=True)"]):
                if args[1] == arg:
                    exec(option)
    elif args[1] == "-Qi":
        pkgs=get_local_pkgs() if len(args[2:]) == 0 else args[2:]
        res=resolve(pkgs, quiet=True)
        detailinfo(res)
    elif args[1] in ["-h", "--help"]:
        help()
    elif args[1] == "--about":
        print(trans["about"]%localdb.get_pkg("buildaur").version)
    elif args[1] in ["--license", "-l"]:
        print(open("/usr/share/licenses/buildaur/LICENSE").read())
    elif args[1] in ["--version", "-v"]:
        print(localdb.get_pkg("buildaur").version)
    elif args[1] == "--listhooks":
        list_hooks()
    elif args[1] == "--hook-activate":
        hooks=[]
        if args[2] == "all":
            hooks+=os.listdir("/etc/buildaur/hooks")
        else:
            hooks=args[2:]
        hook_activate(hooks)
    elif args[1] == "--hook-deactivate":
        hooks=[]
        if args[2] == "all":
            hooktypes=["prehooks", "posthooks", "prerunhooks", "postrunhooks"]
            for hookdir in hooktypes:
                hooks+=os.listdir("/etc/buildaur/"+hookdir)
        else:
            hooks=args[2:]
        hook_deactivate(hooks)
    elif args[1] == "--clear":
        print(trans["cleaning"])
        print(" "+os.popen("echo $(du -hcs ~/.cache/buildaur/build | xargs | awk {'print $1'})").read().split("\n")[0]+trans["will_removed"])
        os.system("rm -rf ~/.cache/buildaur/build/*")
        print(":: Done!")
    elif args[1] == "--make-chroot":
        print(trans["creating_chroot"])
        os.system('sudo rm -rf ~/chroot 2>/dev/null; mkdir ~/chroot; export CHROOT=$HOME/chroot; mkarchroot $CHROOT/root base-devel; echo "export CHROOT=$HOME/chroot" >> $HOME/.bashrc; exit 0')
    elif args[1] == "--show":
        try:
            secarg=args[2]
        except:
            print(trans["error_pkgs_opts"]%red)
            exit(1)
        pkgs=args
        arg=args[1]
        if secarg == "--diff":
            del pkgs[0:3]
            if len(pkgs) == 0:
                print(trans["error_no_pkgs"])
                exit(1)
        else:
            del pkgs[0:2]
        res=resolve(pkgs, quiet=True)
        rescount, cutted=info(res, True)
        for i in range(int(rescount)):
            os.chdir(home+"/.cache/buildaur/build")
            pkg=Informer(cutted, i)
            os.system("rm -rf ./%s 2>/dev/null; git clone %s://aur.archlinux.org/%s 2>/dev/null"%(pkg.name, proto, pkg.name))
            os.chdir(os.getcwd()+"/"+pkg.name)
            if secarg == "--diff":
                os.system('git diff $(git log --pretty=format:"%h" | head -2 | xargs)')
            else:
                pkgbuild = open("PKGBUILD", "rt").read()
                print(pkgbuild)
    else:
        print(trans["error_opts"]%(red, args[1]))
